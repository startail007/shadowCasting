<!DOCTYPE html>
<html>

<head>
    <title>Untitled Document</title>
    <meta charset="UTF-8">
    <meta name="description" content="">
    <meta name="keywords" content="">
</head>

<body>
    <canvas id="canvas" width="600" height="600"></canvas>
</body>

<!--<script>
    let canvas, ctx, w, h, particles;

    function Spark(options) {
        options = options || {};
        this.x = options.x || w * 0.5;
        this.y = options.y || h * 0.5;
        this.v = options.v || {
            direct: Math.random() * Math.PI * 2,
            weight: Math.random() * 14 + 2,
            friction: 0.88+0.06
        };
        this.a = options.a || {
            change: Math.random() * 0.4 - 0.2,
            min: this.v.direct - Math.PI * 0.4,
            max: this.v.direct + Math.PI * 0.4
        };
        this.g = options.g || {
            direct: Math.PI * 0.5 + (Math.random() * 0.4 - 0.2),
            weight: Math.random() * 0.25 + 0.25
        };
        this.width = options.width || Math.random() * 3;
        this.lifespan = options.lifespan || Math.round(Math.random() * 25 + 50);
        this.maxlife = this.lifespan;
        this.color = options.color || '#16d9d9';
        this.prev = {
            x: this.x,
            y: this.y
        };

        this.update = function(index, array) {
            this.prev = {
                x: this.x,
                y: this.y
            };
            this.x += Math.cos(this.v.direct) * this.v.weight;
            this.x += Math.cos(this.g.direct) * this.g.weight;
            this.y += Math.sin(this.v.direct) * this.v.weight;
            this.y += Math.sin(this.g.direct) * this.g.weight;
            this.v.weight > 0.2 && (this.v.weight *= this.v.friction);
            this.v.direct += this.a.change;
            (this.v.direct > this.a.max || this.v.direct < this.a.min) && (this.a.change *= -1);
            this.lifespan > 0 && this.lifespan--;
            this.lifespan <= 0 && this.remove(index, array);
        }

        this.render = function(ctx) {
            if (this.lifespan <= 0) return;
            ctx.beginPath();
            ctx.globalAlpha = this.lifespan / this.maxlife;
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.width;
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.prev.x, this.prev.y);
            ctx.stroke();
            ctx.closePath();
        }

        this.remove = function(index, array) {
            array.splice(index, 1);
        }
    }

    function Particles(options) {
        options = options || {};
        this.max = options.max || Math.round(Math.random() * 10 + 10);
        this.sparks = [...new Array(this.max)].map(() => new Spark(options));

        this.update = function() {
            this.sparks.forEach((s, i) => s.update(i, this.sparks));
        }

        this.render = function(ctx) {
            this.sparks.forEach(s => s.render(ctx));
        }
    }

    function update() {
        particles.forEach(p => p.update());
    }

    function render() {
        ctx.globalCompositeOperation = 'source-over';
        /*ctx.globalAlpha = 1;
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, w, h);*/
        ctx.clearRect(0, 0, w, h);
        ctx.globalCompositeOperation = 'screen';
        particles.forEach(p => p.render(ctx));
    }

    function loop() {
        update();
        render();
        requestAnimationFrame(loop);
    }
    (function() {
        //
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;
        particles = [];
        canvas.addEventListener('mousemove', (e) => {
            const x = e.clientX;
            const y = e.clientY;
            particles.push(new Particles({
                x: x,
                y: y
            }));
        });
        loop();
    })()
</script>-->
<script type="text/javascript">

    var point = function (x, y) {
        this.x = x;
        this.y = y;
        this.add = function (v) {
            return new point(this.x + v.x, this.y + v.y);
        }
        this.rotate= function (pValue) {
            var cos0 = Math.cos(pValue);
            var sin0 = Math.sin(pValue);
            return new point(this.x * cos0 - this.y * sin0, this.y * cos0 + this.x * sin0);
        }
        this.getVector= function (pP) {
            return new vector(pP.x - this.x, pP.y - this.y);
        }       
        this.interpolationV= function (pV, t) {
            var v0 = pV.scale(t);
            return new point(this.x + v0.x, this.y + v0.y);
        }
        this.interpolation= function (pP, t) {
            var v = this.getVector(pP);
            return this.interpolationV(v, t);
        }
    };

    //向量
    var vector = function (x, y) {
        this.x = x;
        this.y = y;
        this.length = function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        this.dot = function (v) {
            return this.x * v.x + this.y * v.y
        }
        this.cross = function (v) {
            return this.x * v.y - this.y * v.x;
        }
        this.scale = function (n) {
            return new vector(this.x * n, this.y * n);
        }
        this.add = function (v) {
            return new vector(this.x + v.x, this.y + v.y);
        }
        this.sub = function (v) {
            return new vector(this.x - v.x, this.y - v.y);
        }
        this.swap = function () {
            return new vector(-this.y, this.x);
        }
        this.projection = function (v) {
            var temp = this.dot(v) / v.length();
            return new vector(v.x * temp, v.y * temp);
        }
        this.normalize = function () {
            var r = this.length();
            return new vector(this.x / r, this.y / r);
        }
        this.reflection = function (f) {
            var fn = f.normalize();
            var v0_u = this.projection(fn);
            var v0_v = this.sub(v0_u);
            var v1 = v0_v.scale(-1).add(v0_u).normalize();
            return v1;
        }
        this.refraction = function (n, f) {
            var fn = f.normalize();
            var fnv = fn.swap();
            var n0 = n;
            var temp = this.sub(this.projection(fn)).cross(fn);
            if (temp > 0) {
                fn = fn.scale(-1);
                fnv = fn.swap();
            }
            var v0_u = this.projection(fn);
            var v0_v = this.sub(v0_u);
            /*var v0_temp = new vector(
                v0_u.length() * (v0_u.cross(fnv) > 0 ? 1 : -1),
                v0_v.length() * (v0_v.cross(fn) > 0 ? 1 : -1)
            );
            var s = n * v0_temp.x / v0_temp.length();*/
            var v0_temp = new vector(v0_u.length(), v0_v.length());
            var s = n0 * (v0_u.cross(fnv) > 0 ? 1 : -1) * v0_temp.x / v0_temp.length();
            if (Math.abs(s) >= 1) {
                return null;
            }
            var v1_temp = new vector(s, Math.sqrt(1 - s * s));
            var v1 = new vector(
                v1_temp.x * fn.x + v1_temp.y * fnv.x,
                v1_temp.x * fn.y + v1_temp.y * fnv.y
            );
            return v1;
        }
        this.rotate = function (pAngle) {
            var cos0 = Math.cos(pAngle);
            var sin0 = Math.sin(pAngle);
            return new vector(this.x * cos0 - this.y * sin0, this.y * cos0 + this.x * sin0);
        }
    }

    function intersection(pP0S, pP0E, pP1S, pP1E) {
        var v0 = pP0S.getVector(pP0E);
        var v1 = pP1S.getVector(pP1E);
        return intersectionPV(pP0S, v0, pP1S, v1);
    }

    function intersectionPV(pP0, pV0, pP1, pV1) {
        var c1 = pV0.cross(pV1);
        var v2 = pP0.getVector(pP1);
        var c2 = v2.cross(pV1);
        if (c1 == 0) {
            /*if (c2 == 0) {
                return "兩線重疊";
            }else{                
                return "兩線平行但不重疊";
            }*/
            return null;
        }
        var tv = pP0.getVector(pP1);
        return {
            t0: tv.cross(pV1) / c1,
            t1: tv.cross(pV0) / c1
        };
    }

    var canvas, ctx, w, h, particles;
    var polygons = [];
    polygons.push({
        points:[new point(50,50),new point(175,75),new point(50,150)],
        color:"#ff0000",
        type:"fill"
    });
    polygons.push({
        points:[new point(250,150),new point(375,175),new point(250,250)],
        color:"#00ff00",
        type:"fill"
    });
    polygons.push({
        points:[new point(375,250),new point(475,375),new point(375,450)],
        color:"#0000ff",
        type:"fill"
    });


    var lines = [];
    var lightPolygons = [];
    function update(){

    }
    function render() {
        //ctx.globalCompositeOperation = 'source-over';
        /*ctx.globalAlpha = 1;
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, w, h);*/
        ctx.clearRect(0, 0, w, h);
        //ctx.globalCompositeOperation = 'screen';
        for(var temp in polygons){
            var polygon = polygons[temp];
            drawPolygon(ctx,polygon.points,polygon.color,polygon.type);
        }
        /*for(var temp in lightPolygons){
            var lightPolygon = lightPolygons[temp];
            drawPolygon(ctx,lightPolygon.points,lightPolygon.color,lightPolygon.type);
        }*/
        for(var temp in lines){
            var line = lines[temp];
            drawPolygon(ctx,line.points,line.color,line.type);
        }
        //particles.forEach(p => p.render(ctx));
    }
    function loop() {
        update();
        render();
        requestAnimationFrame(loop);
    }
    function drawPolygon(ctx,points, color, type) {
        //console.log(ctx)
        ctx.beginPath();
        for(var temp in points){
            var point01 = points[temp];
            ctx[temp==0?"moveTo":"lineTo"](point01.x, point01.y);
            //console.log(i==0?"moveTo":"lineTo")
        }
        ctx[type + 'Style'] = color;
        ctx.closePath();
        ctx[type]();
    }




    (function() {
        //
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        w = window.innerWidth;
        h = window.innerHeight;
        /*canvas.width = w;
        canvas.height = h;*/
        canvas.addEventListener('mousemove', (e) => {
            var x = e.clientX;
            var y = e.clientY;
            /*var x = 250;
            var y = 100;*/
            var temp_points = [];            
            //var temp_lines = [];
            for(var temp0 in polygons){
                var temp = polygons[temp0].points;
                for(var temp1 in temp){
                    temp_points.push(temp[temp1]);
                }
            }
            temp_points.push(new point(0,0));
            temp_points.push(new point(600,0));
            temp_points.push(new point(600,600));
            temp_points.push(new point(0,600));

            var temp_lines = [];
            for(var temp0 in polygons){
                var temp = polygons[temp0].points;
                for(var i = 0;i<temp.length;i++){
                    temp_lines.push({A:temp[i],B:temp[(i+1)%temp.length]});
                }
            }

            var point01 = new point(x,y);            
            var temp_points01 = [];
            lines = [];
            for(var temp0 in temp_points){
                /*var a = point01.getVector(temp_points[temp0]);
                var b = a.normalize().scale(600*Math.sqrt(2));
                var c = point01.add(b);
                temp_points01.push(c);*/
                temp_points01.push(temp_points[temp0]);
            }
                
            for(var temp0 in temp_points01){
                var point02 = temp_points01[temp0];
                var len = Infinity;
                var p = null;
                for(var temp1 in temp_lines){
                    var point03 = temp_lines[temp1].A;                      
                    var point04 = temp_lines[temp1].B;
                    var v0 = point01.getVector(point02);                    
                    var v1 = point03.getVector(point04);
                    var temp = intersectionPV(point01,v0,point03,v1);
                    console.log(temp)
                    if(temp!=null && (temp.t0>0 && temp.t0<1 && temp.t1>0 && temp.t1<1)){
                        var temp = point01.interpolationV(v0,temp.t0);
                        var temp_len = point01.getVector(temp).length();
                        if(temp_len<len){
                            len = temp_len;
                            p = temp;
                        }
                    }
                }
                lines.push({
                    points:[point01,(p!=null)?p:point02],
                    color:"#ffffff",
                    type:"stroke"
                });
                
            }
            /*var point01 = new point(x,y);
            var points01 = [];
            for(var temp0 in temp_points){
                //if(temp0==0 || temp0==1){
                    var point02 = temp_points[temp0];
                    var bool = true;
                    for(var temp1 in temp_lines){
                        var point03 = temp_lines[temp1].A;                      
                        var point04 = temp_lines[temp1].B;
                        var temp = intersection(point01,point02,point03,point04);
                        //console.log(temp)
                        //console.log(temp,point02)
                        if(temp=="兩線重疊"){
                            //平行時執行 需要判斷線段重疊
                            var a0 = point03.x-point01.x;
                            var a1 = point04.x-point01.x;                             
                            var b = point02.x-point01.x;
                            if(a0*b >= 0 && Math.abs(a0)<Math.abs(b)){
                                bool = false;
                                break;
                            }else if(a1*b >= 0 && Math.abs(a1)<Math.abs(b)){
                                bool = false;
                                break;
                            }

                            var a0 = point03.y-point01.y;
                            var a1 = point04.y-point01.y;                             
                            var b = point02.y-point01.y;
                            if(a0*b >= 0 && Math.abs(a0)<Math.abs(b)){
                                bool = false;
                                break;
                            }else if(a1*b >= 0 && Math.abs(a1)<Math.abs(b)){
                                bool = false;
                                break;
                            }

                            console.log('兩線重疊')
                        }else if(temp=="兩線平行但不重疊"){
                            console.log('兩線平行但不重疊')
                        }else if((temp.t0>0 && temp.t0<1 && temp.t1>0 && temp.t1<1)){
                            bool = false;
                            break;
                        }
                    }
                    if(bool){
                        //var point05 = point01.interpolation(point02,temp.t0);
                        points01.push({point:point02,rotation:0});
                    }
                //}
            }*/
            


            /*for(var temp1 in points01){
                var temp = point01.getVector(points01[temp1].point);
                points01[temp1].rotation = Math.atan2(temp.y, temp.x)*180/Math.PI;
                if(points01[temp1].rotation<0){
                    points01[temp1].rotation+=360;
                }
            }

            function sortNumber(a,b)
            {
                return a.rotation - b.rotation
            }

            points01.sort(sortNumber);*/

            //console.log(points01)

            
            /*lightPolygons = [];
            for(var i = 0;i<points01.length;i++){
                lightPolygons.push({
                    points:[point01,points01[i].point,points01[(i+1)%points01.length].point],
                    color:"#ffff00",
                    type:"fill"
                });
            }*/
            /*lightPolygons = [];
            var temp = [];
            for(var i = 0;i<points01.length;i++){
                temp.push(points01[i].point);
            }
            lightPolygons.push({
                points:temp,
                color:"#ffff00",
                type:"fill"
            });*/

            //console.log(lightPolygons)
            //console.log(temp_lines);
            /*var point01 = new point(x,y);
            var point02 = polygons[0].points[0];            
            var point03 = polygons[0].points[1];                      
            var point04 = polygons[0].points[2];         
            lines = [];
            var temp = intersection(point01,point02,point03,point04);
            if(temp.t0>0 && temp.t0<1 && temp.t1>0 && temp.t1<1){
                
            }else{
                var point05 = point01.interpolation(point02,temp.t0);
                lines.push({
                    points:[point01,point02],
                    color:"#0000ff",
                    type:"stroke"
                });
            }*/

            //console.log()

            /*lines[0] = {
                points:[point01,point02],
                color:"#0000ff",
                type:"stroke"
            }
            lines[1] = {
                points:[point03,point04],
                color:"#0000ff",
                type:"stroke"
            }*/
            //console.log(temp)
        });
        loop();
    })()
</script>
<style>
    body {
        /*background-color: #000;*/
        margin: 0;
        overflow: hidden;
    }
    canvas {
        background-color: #000;
    }
</style>

</html>